---
title: "Гравитационная модель Хаффа"
format: html
---

# Теория

Материалы лекции

```{=html}
<iframe src="https://baltti.github.io/gravity-model/" width="1000" height="500"></iframe>
```

[Открыть лекцию в новой вкладке](https://baltti.github.io/gravity-model/){target="_blank"}

# Исходные данные

В качестве исходных данных нам необходимы:

-   жилые дома - место жизни наших потенциальных покупателей;

-   улично-дорожная сеть, которая будет использоваться для расчета времени в пути от жилого дома до магазина;

-   слой с локациями торговых точек.

Первые два слоя необходимо скачать из OSM аналогично [исходным данным в предыдущей работе](https://baltti.github.io/spatial-analysis/02-location-allocation.html#%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5) или же можно взять из предыдущей работы готовые данные.

Слой с локациями торговых точек мы создадим самостоятельно. Для этого в строке меню необходимо выбрать *Слой* $\longrightarrow$ *Создать слой* $\longrightarrow$ *Создать слой GeoPackage*.

Далее в открывшемся окне следует указать характеристики слоя:

-   база данных - это путь к файлу, в котором будет храниться слой;

-   имя таблицы - название слоя, которое будет отображаться в панели слоев;

-   тип геометрии - нам нужны точечные объекты;

-   система координат - можно оставить географическую систему координат по умолчанию, она будет совпадать с системой координат данных, скачанных из OSM;

-   список полей, который будет включать два обязательных для нас поля - **name** (название магазина, текстовый формат данных) и **area** (площадь магазина в метрах квадратных, целое число).

![](images/Снимок%20экрана%202025-02-21%20в%2017.15.27.png){fig-align="center"}

После создания слоя, его необходимо будет сделать редактируемым и нарисовать на карте несколько точек в разных частях исследуемой территории и заполнить для них атрибутивные данные - название магазина и площадь.

::: callout-warning
Названия точек должны быть уникальными, в противном случае модель не будет работать.
:::

![](images/Снимок%20экрана%202025-02-24%20в%2013.04.14.png){fig-align="center"}

# Построение геомодели {#geomodel .section}

В этой работе мы будем оценивать вероятность посещения того или иного магазина, исходя из их доступности и площади (как прокси-метрики разнообразия ассортимента), с использованием гравитационной модели Хаффа.

$$P_{ij} = \frac{\frac{S_{j}}{T^\lambda_{ij}}}{\sum_{j}^{n}\frac{S_{j}}{T^\lambda_{ij}}}$$

-   $P_{ij}$ - вероятность того, что покупатель из локации $i$ пойдет в магазин $j$;
-   $S_{j}$ - площадь магазина $j$;
-   $T_{ij}$ - время/расстояние, которое нужно преодолеть, чтобы попасть в магазин;
-   $\lambda$ - параметр, отражающий влияние времени в пути на покупателя.

::: callout-warning
Мы воспользуемся упрощенной моделью, приняв параметр $\lambda$ равным единице, так как у нас нет подробных данных о предпочтениях покупателей.
:::

Для построения моделей будем использовать редактор моделей.

::: callout-tip
Редактор моделей позволяет выстроить последовательный процесс вычислений из цепочки операций с помощью простого графического интерфейса.

Полученная геомодель позволяет автоматизировать вычисления и избежать вывода промежуточных результатов.

Подробнее про построение геомоделей можно в [документации](https://docs.qgis.org/3.34/en/docs/user_manual/processing/modeler.html)
:::

Открыть редактор моделей можно из строки меню *Анализ данных* $\longrightarrow$ *Конструктор моделей* или по клику на кнопку *Модели* в Панели инструментов анализа.

![](images/Снимок%20экрана%202025-02-24%20в%2013.07.26.png){fig-align="center"}

В открывшемся новом окне основная часть предназначена для отображения модели в графическом виде, слева панель данных и алгоритмов (переключаются по вкладкам внизу панели), свойства и переменные модели, а также история команд.

![](images/Снимок%20экрана%202025-02-24%20в%2013.08.29.png){fig-align="center"}

## Входные данные

В первую очередь зададим для нашей модели входные данные. В нашем случае все входные данные будут представлены в виде векторных слоев:

-   здания - обязательный параметр, полигоны;

-   магазины - обазятельный параметр, точки;

-   улично-дорожная сеть - обязательный параметр, линии.

::: callout-note
Обязательный параметр - это тот, без включения которого в исходные данные запуск модели осуществляться не будет.
:::

::: callout-warning
Желательно называть входные данные буквами английского алфавита, так как иногда они могут не добавляться в модель или работать некорректно при использовании кириллицы.
:::

![](images/Снимок%20экрана%202025-02-24%20в%2013.15.30.png){fig-align="center"}

Входные данные в модели обозначаются зеленым плюсом перед названием.

![](images/Снимок%20экрана%202025-02-24%20в%2013.16.30.png){fig-align="center"}

## Расчет матрицы старт-назначение между потребителями и сервисами

Также как и для анализа размещения-распределения нам необходимо преобразовать полигональные здания в точечные объекты с помощью инструмента *Точка на поверхности*.

![](images/Снимок%20экрана%202025-02-24%20в%2013.20.56.png){fig-align="center"}

В модели появится первый шаг, соединенный с одним из исходных параметров.

![](images/Снимок%20экрана%202025-02-24%20в%2013.21.30.png){fig-align="center"}

Далее мы можем непосредственно рассчитать матрицу старт-назначение с использованием плагина QNEAT3.

![](images/Снимок%20экрана%202025-02-24%20в%2013.23.16.png){fig-align="center"}

Параметры здесь указываются аналогично тому, как указывались просто в инструменте для построения матрицы.

Так как нам здесь нет необходимости впоследствии визуально отображать пути покупателей от жилых домов до магазинов, то строить матрицу будем просто в виде таблицы на основе двух слоев.

::: callout-warning
Идентификаторы объектов стартовых и конечных точек должны быть уникальными (внутри слоя естественно).

В нашем случае для стартовых точек (домов) будет использовать *osm_id*, который всегда будет уникальным и есть в этом слое, так как данные брались из OSM, а для магазинов будет использоваться поле имени *name* (поэтому нам очень важно, чтобы в этом слое названия магазинов были уникальными).
:::

Так как в качестве стартовых точек мы используем не непостредственно здания, а результат применения инструмента *Точки на поверхности*, то необходимо выбрать, что здесь мы хотим использовать результаты выхода этого алгоритма.

![](images/Снимок%20экрана%202025-02-24%20в%2013.28.29.png){fig-align="center"}

Полученный результат будет представлен только в виде **таблицы без атрибутов**, которую можно присоединить к одному из векторных слоев.

Так как мы будет рассчитывать вероятность посещения того или иного магазина для каждого из жилых домов, то основной расчет вероятности будет осуществляться внутри атрибутов жилых домов. Поэтому значения времени или расстояния из матрицы старт-назначение присоединим к слою жилых домов.

Присоединение будет осуществляться по совпадающим значениям полей: у исходного слоя есть *osm_id*, а в матрице есть *origin_id* - идентификатор стартовой точки, который был взят из *osm_id* исходного слоя.

![](images/Снимок%20экрана%202025-02-24%20в%2013.36.08.png){fig-align="center"}

## Расчет вероятности посещения конкретного сервиса

Если мы обратимся к формуле в начале раздела, то увидим, что в формуле используется не только расстояние между потребителями и сервисом, но и площадь сервиса.

Поэтому атрибуты магазинов тоже следует присоединить к слою жилых домов.

![](images/Снимок%20экрана%202025-02-24%20в%2013.50.17.png){fig-align="center"}

Присоединение здесь будет осуществляться по названию магазина к результатам предыдущего шага, поэтому в качестве связыющих полей будет использовано *destination_id* и поле *name* слоя с магазинами.

::: callout-note
Обратите внимание, что тип объединения здесь один-ко-многим, то есть если с объектом исходного слоя совпадет более одного объекта присоединяемого слоя, то исходный объект будет продублирован и к нему присоединен атрибут второго совпавшего объекта.

В нашем случае это необходимо так как нужно рассчитать вероятность для всех магазинов и, если мы присоединим только первый совпавший по атрибуту, то в расчет мы сможем включить только его и таким образом получим безальтернативную вероятность посещения только одного магазина.
:::

::: callout-tip
Для того, чтобы не запутаться в однотипных операциях в одинаковыми названиями, вы можете менять его в графе *Описание* (*Description*).
:::

Следующим шагом рассчитаем числитель в формуле: $\frac{S_{j}}{T^\lambda_{ij}}$, разделив площадь каждого магазина на время в пути до него с помощью калькулятора полей.

![](images/Снимок%20экрана%202025-02-24%20в%2015.08.55.png){fig-align="center"}

::: callout-note
Калькулятор полей здесь устроен почти также как и стандартный калькулятор в таблице атрибутов. Все функции и формулы стандратны.

*Обязательно здесь необходимо указать название нового поля и тип данных*.
:::

Следующим шагом нужно рассчитать знаменатель модели: $\sum_{j}^{n}\frac{S_{j}}{T^\lambda_{ij}}$.

Для этого необходимо фактически просуммировать все полученные нами на предыдущем шаге значения, но только для каждого жилого дома и соответствующих магазинов. То есть нам нужно просуммировать не все значения по столбцу, а только значения соответствующие одному жилому дому.

Расчет осуществим с использованием SQL-запроса и оконной функции внутри него.

::: callout-tip
**Оконная функция в SQL** - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.

Основное отличие оконной функции от группировки по параметру состоит в том, что количество строк в запросе не уменьшается по сравнении с исходной таблицей.

Подробнее можно почитать по [ссылке](https://habr.com/ru/articles/664000/).
:::

Получается, что в нашем запросе сначала таблица будет поделена на группы строк, соответствующие одному и тому же жилому дому (имеющие один и тот же индентификатор дома), а потом суммирование значений будет производиться только в пределах этих групп строк.

Структура запроса:

```         
select origin_id, destination_id, total_cost, area, area_time, geometry,  sum(area_time) over (partition by origin_id) as summa from input1
```

![](images/Снимок%20экрана%202025-02-24%20в%2015.18.07.png){fig-align="center"}

И последним шагом рассчитаем вероятность посещения того или иного магазина, еще раз использовав калькулятор полей и поделив друг на друга два полученных нами на последних шагах значения.

![](images/Снимок%20экрана%202025-02-24%20в%2015.21.46.png){fig-align="center"}

Этот результат уже можно рассматривать как итоговый и ввести его название, чтобы это считалось выводом всей модели.

![](images/Снимок%20экрана%202025-02-24%20в%2015.22.19.png){fig-align="center"}

Полученная схема модели показана на рисунке ниже.

![](images/Снимок%20экрана%202025-02-24%20в%2015.23.30.png){fig-align="center"}

Перед запуском модель можно проверить командой из строки меню *Модель* $\longrightarrow$ *Проверить модель*.

Запуск модели осуществляется либо по кнопке ![](images/Снимок%20экрана%202025-02-24%20в%2015.25.27.png){width="21"}, либо из строки меню *Модель* $\longrightarrow$ *Запустить модель.*

После запуска модель выглядит практически как стандартный инструмент из Панели инструментов анализа.

![](images/Снимок%20экрана%202025-02-24%20в%2015.26.48.png){fig-align="center"}

Полученный результат на карте будет выглядеть идентично исходному слою жилых зданий, так как использовалась их неизмененная геометрия.

Самая интересная часть результатов - это атрибутивная таблица со всеми значениями.

![](images/Снимок%20экрана%202025-02-24%20в%2015.32.37.png){fig-align="center"}

В этой таблице как раз можно увидеть повторяемость каждого из зданий (обратите внимание, что в колонке *origin_id* значения повторяются столько раз, сколько у вас было магазинов в примере):

-   *origin_id* - идентификатор дома из исходных данных;

-   *destination_id* - идентификатор (название) магазина из исходных данных;

-   *total_cost* - расстояние от конкретного дома до магазина из матрицы старт-назначение;

-   *area* - площадь магазина из исходных данных;

-   *area_time -* отношение площади магазина к расстоянию, рассчитанное на промежуточном этапе;

-   *summa -* сумма всех предыдущих значение для каждого дома;

-   *probability* - вероятность посещения конкретного магазина жителями этого дома.

::: callout-tip
Проверить корректность своих расчетов можно проверив два условия:

-   вероятность (последняя колонка может находиться только в пределах от нуля до единицы);

-   сумма вероятностей для каждого дома должна равняться единице.
:::

В качестве финального этапа можем разделить полученный в итоге слой так, чтобы для каждого из магазинов был свой отдельный слой.

Для этого воспользуемся инструментом *Разбить векторный слой* и разобьем его на отдельные слои по идентификаторам магазинов.

![](images/Снимок%20экрана%202025-02-24%20в%2015.40.16.png){fig-align="center"}

Здесь результат тоже будет выводиться как конечный.

Таким образом, по результату запуска модели будет выводиться слой, содержащий вероятности по всем домам и магазинам, и слои, содержащие вероятности по отдельным магазинам (этих слоев будет столько, сколько было магазинов в исходном слое).

::: callout-tip
При необходимости вы можете сделать столько выводов из модели, сколько посчитаете нужным.
:::

![](images/Снимок%20экрана%202025-02-24%20в%2015.44.05.png){fig-align="center"}

Окно запуска модели немного изменится: в нем появится возможность выбора папки для сохранения наших результатов разделения слоя.

![](images/Снимок%20экрана%202025-02-24%20в%2015.44.38.png){fig-align="center"}

В выбранной папке по результатам работы модели появятся файлы с префиксом *destination_id\_* и названием магазина: ![](images/Снимок%20экрана%202025-02-24%20в%2015.46.44.png).

Атрибутивная таблица сохранит свою структуру, но, естественно будет содержать только данные по одному из магазинов.

![](images/Снимок%20экрана%202025-02-24%20в%2015.48.24.png){fig-align="center"}

Полученная модель может быть сохранена как отдельный файл в формате *.model3* (*Модель* $\longrightarrow$ *Сохранить модель как*) или как часть проекта (*Модель* $\longrightarrow$ *Сохранить модель в проекте).*

![](images/Снимок%20экрана%202025-02-24%20в%2015.49.45.png){fig-align="center"}

::: callout-tip
Если бы было известно количество жителей в каждом доме, то можно было бы рассчитать потенциальное число покупателей для каждого из магазинов по формуле:

$$
E_{ij} = P_{ij}C_{i}
$$

где $E_{ij}$ - предполагаемое количество покупателей из локации $i$, которые пойдут в магазин $j$;

$P_{ij}$ - вероятность того, что покупатель из локации $i$ пойдет в магазин $j$;

$C_{i}$ - количество покупателей в локации $i$.
:::

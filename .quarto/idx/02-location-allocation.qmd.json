{"title":"Анализ размещения-распределения","markdown":{"yaml":{"title":"Анализ размещения-распределения","format":"html"},"headingText":"Общие сведения","containsRefs":false,"markdown":"\n\n\nАнализ размещения-распределения (location-allocation analysis) необходим для решения двух основных задач:\n\n-   поиск **оптимального размещения** объекта относительно точек спроса с учетом минимизации транспортных расходов (времени в пути или затрат на перевозку), например, размещение экстренных служб, которые должны располагаться так, чтобы время их прибытия было минимальным;\n\n-   поиск **оптимального распределения** от размещаемого нового объекта до точек спроса с учетом минимизации транспортных расходов, например, размещение склада, с которого осуществляется доставка, или размещение даркстора службы доставки, чтобы максимально охватывать зоной доставки ближайшее окружение.\n\nОсновная часть решения таких задач сводится к определению медианного расположения: необходимо таким образом разместить медианную точку, чтобы минимизировать среднюю стоимость транспортировки с учетом спроса или расстояние между точками спроса и сервисом[^1]. Параметры решения будут зависеть от трех показателей:\n\n[^1]: Один из классических методов решения медианной задачи описан по [ссылке](https://transportgeography.org/contents/chapter2/transport-and-location/weber-location-triangle/)\n\n-   количество точек сервиса, которые необходимо разместить;\n\n-   количество, тип и размещение точек спроса - точки спроса могут представлять собой как индивидуальные локации, так и центры полигонов (например, административно-территориальных единиц), наиболее простым случаем здесь будет являться небольшое число равномерно распределенных по территории точек спроса;\n\n-   тип рассчитываемого расстояния.\n\nФактически решение этой задачи сводится к линейной оптимизации.\n\n$$ Min: \\sum_{a} \\sum_{b}g(Q(a,b)),\\ Q(a,b)\\geq0\n$$\n\nгде $Q(a,b)$ - трафик между источником $a$ и пунктом назначения $b$ , $g$ - функция стоимости.\n\nТо есть $g(Q(a,b))$ - транспортные расходы, связанные с перевозками из точки $a$ в пункт назначения $b$.\n\nДля анализа городской среды наиболее простым примером является поиск оптимального расположения объектов сервиса так, чтобы их зона обслуживания охватывала как можно больше горожан (потребителей этих сервисов) при минимальном до них расстоянии.\n\n![Размещение и площадь распределительных складов Amazon с учетом расселения[^2]](images/Map-Amazon-Density-and-Median-1.webp){fig-align=\"center\"}\n\n[^2]: Источник: <https://transportgeography.org/contents/methods/location-allocation-models/weighted-median-location-amazon-distribution-facilities/>\n\n[^3]: Источник: <https://transportgeography.org/contents/methods/location-allocation-models/weighted-median-location-amazon-distribution-facilities/>\n\n![Поиск наиболее оптимального расположения больниц[^4]](images/Без%20заголовка.png){fig-align=\"center\"}\n\n[^4]: Источник: <https://www.esri.com/about/newsroom/wp-content/uploads/2018/10/solving-a-public-health-problem.pdf>\n\n[^5]: Источник: <https://www.esri.com/about/newsroom/wp-content/uploads/2018/10/solving-a-public-health-problem.pdf>\n\n# Определение ближайшего сервиса на основе матрицы старт-назначение\n\nВ этой работе мы определим ближайшую локацию сервиса относительно жилых домов с использованием матрицы старт-назначение.\n\n::: callout-note\nМатрица старт-назначение - таблица, содержащая в себе значения времени или расстояния перевозки между всеми возможными парами стартовых точек и точек назначения.\n:::\n\n![Пример матрицы старт-назначение[^6]](images/generated_webp_full_reading-matrix.webp){fig-align=\"center\"}\n\n[^6]: Источник: <https://docs.platform-xyzt.ai/articles/origin-destination/introduction.html>\n\n[^7]: Источник: <https://docs.platform-xyzt.ai/articles/origin-destination/introduction.html>\n\nПрактическое занятие основано на [туториале](https://www.qgistutorials.com/en/docs/3/origin_destination_matrix.html).\n\n## Исходные данные {#location-allocation-data}\n\nДля расчетов нам необходимо три набора данных:\n\n-   жилые дома (полигоны) - точки спроса, которые будут служит стартовыми точками для расчета матрицы старт-назначение;\n\n-   точки сервиса (точки), которые будут служить конечными точками при расчете матрицы старт-назначение (вы можете выбрать точки сервиса, которые посчитаете нужным);\n\n-   улично-дорожная сеть (линейные объекты) для расчета расстояния или времени в пути.\n\nВсе данные следует загрузить из OSM с использованием плагина QuickOSM.\n\n::: callout-tip\nКак пользоваться плагином описано по [ссылке](https://baltti.github.io/geoinformatics-2.0/osm.html#quickosm)\n:::\n\nДля загрузки жилых домов будет использован запрос `building=apartments`.\n\nДля точек сервиса можно использовать одно из значений ключа `amenity` (подробнее [здесь](https://wiki.openstreetmap.org/wiki/RU:Key:amenity)) или `shop` (подробнее про него [здесь](https://wiki.openstreetmap.org/wiki/RU:Key:shop)). Здесь будут использованы супермаркеты, поэтому был использован запрос `shop=supermarket` .\n\nОбъекты улично-дорожной сети определялись по запросу `highway=primary or highway=secondary or highway=tertiary`.\n\n::: callout-warning\nВ нашем пример для построения маршрутов будут учитываться только наиболее крупные городские магистрали для ускорения и упрощения расчетов, что может привести к не очень реалистичной картине доступности сервисов. Если вы хотите выполнить расчет более корректно, лучше будет включить в него и более мелкие улицы. Полный перечень типов дорог и значений ключей для них приведен по [ссылке](https://wiki.openstreetmap.org/wiki/RU:Key:highway).\n:::\n\n![Подготовленный для анализа проект с загруженными слоями](images/Снимок%20экрана%202025-02-21%20в%2012.52.58.png){fig-align=\"center\"}\n\n::: callout-warning\nЧем больше будет ваша территория для анализа, тем дольше будет осуществляться расчет. То же самое касается и количества объектов: чем больше у вас домов или точек сервиса, тем дольше будут идти расчеты.\n:::\n\n## Расчет матрицы старт-назначение\n\nДля расчета матрицы воспользуемся уже знакомым нам по прошлому семестру плагином QNEAT3.\n\nНо предварительно нужно подготовить наши данные о жилых домах: пока они у нас представлены в виде полигонов, но плагин может осуществлять расчеты только между двумя слоями точечных объектов, поэтому необходимо из полигонов получить точки.\n\nПерейти от точек к полигонам мы можем либо построив центроиды, либо воспользовавшись инструментом *Точка на поверхности*.\n\nВ первом варианте мы получим геометрические центры полигонов, но в случае сложной формы зданий, они могу лежать за его пределами, тогда как при использовании инструмента *Точка на поверхность* полученные точечные объекты будут гарантированно размещены внутри полигонов.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.06.51.png){fig-align=\"center\"}\n\nВ данном случае было выбрано создавать точки для каждой части мультиполигонов, чтобы не были потеряны отдельные части зданий.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.09.45.png){fig-align=\"center\"}\n\n::: callout-tip\nДля улучшения качества расчетов можно воспользоваться не просто центром здания, а точками подъездов.\n:::\n\nДалее построим матрицу старт-назначение. Для этого воспользуемся инструментом *OD Matrix from Layers as Lines (m:n)*. В данном случае мы построим не просто таблицу, а векторный линейный слой, в котором будут соединяться все возможные пары дом-супермаркет.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.11.57.png){fig-align=\"center\"}\n\nВ качестве необходимых параметров следует указать:\n\n-   *network layer* - слой, содержащий объекты улично-дорожной сети;\n\n-   *from-point layer* - слой стартовых точек;\n\n-   *unique point ID field* - **уникальный идентификатор** стартовых точек;\n\n-   *to-point layer* - слой конечных точек;\n\n-   *unique point ID field* - **уникальный идентификатор** конечных точек;\n\n-   *optimization criterion* - показатель, минимизируемый при расчете маршрута: кратчайший или быстрейший).\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.12.24.png){fig-align=\"center\"}\n\nВ дополнительных параметрах укажем среднюю скорость пешехода - 5 км/ч (*default speed*) и стиль генерации линий - по прямой (*generated matrix geometry style*). Второй вариант генерации линий будет повторять сегменты улично-дорожной сети, но такое построение требует большего времени и ресурса компьютера, поэтому остановимся на более простом варианте.\n\nПо результатам расчета вы получите довольно неясную картинку, в которой будет много пересекающихся между собой линий - это графическая интерпретация матрицы старт-назначение.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.22.40.png){fig-align=\"center\"}\n\nЕсли вы откроете таблицу атрибутов полученного слоя, вы увидите собственно матрицу старт-назначение.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.24.25.png){fig-align=\"center\"}\n\nОбратите внимание, что расстояние в пути (cost) представлено сразу четырьмя атрибутами:\n\n-   *entry_cost* - расстояние, которое нужно пройти, чтобы от стартовой точки попасть на ближайший сегмент улично-дорожной сети;\n\n-   *network_cost* - расстояние, которое будет пройдено только по сегментам улично-дорожной сети;\n\n-   *exit_cost -* расстояние, которое нужно пройти от ближайшего к конечной точке сегмента улично-дорожной сети до конечной точки;\n\n-   *total_cost* - сумма перечисленных выше расстояний.\n\n## Определение ближайшего объекта сервиса\n\nПоследний шаг нашего расчета - это из всех возможных пар жилой дом-супермаркет найти те, которые расположены ближе всего друг к другу. Для этого мы выполним SQL-запрос.\n\nВ качестве источника данных следует выбрать вычисленную матрицу старт-назначение (в моем случае это слой *Output OD matrix*), а сам запрос будет выглядеть следующим образом:\n\n```         \nselect origin_id, destination_id, min(total_cost) as shortest_distance, geometry\nfrom input1 group by origin_id\n```\n\nТак как структура матрицы стандартна, то и запрос будет выглядеть у всех одинаково.\n\n::: callout-tip\nОбратите внимание на то, что в запросе использован поиск минимального значения для поля *total_cost*, так как нам необходимо найти ближайшие к жилым домам супермаркеты, кроме того здесь использован псевдоним этого поля (задается с помощью *as*).\n\nТакже следует отметить, что необходимо включать в запрос поле *geometry*, так как без него будет осуществлен только поиск прочих атрибутов и геометрия будет исключена.\n:::\n\nВ результате выполнения запроса будет получен новый слой, показывающий жители каких домов наиболее вероятно будут ходить в какие магазины, так как эти магазины являются к ним ближайшими. Также этот результат можно рассматривать как зоны обслуживания магазинов.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.40.26.png){fig-align=\"center\"}\n","srcMarkdownNoYaml":"\n\n# Общие сведения\n\nАнализ размещения-распределения (location-allocation analysis) необходим для решения двух основных задач:\n\n-   поиск **оптимального размещения** объекта относительно точек спроса с учетом минимизации транспортных расходов (времени в пути или затрат на перевозку), например, размещение экстренных служб, которые должны располагаться так, чтобы время их прибытия было минимальным;\n\n-   поиск **оптимального распределения** от размещаемого нового объекта до точек спроса с учетом минимизации транспортных расходов, например, размещение склада, с которого осуществляется доставка, или размещение даркстора службы доставки, чтобы максимально охватывать зоной доставки ближайшее окружение.\n\nОсновная часть решения таких задач сводится к определению медианного расположения: необходимо таким образом разместить медианную точку, чтобы минимизировать среднюю стоимость транспортировки с учетом спроса или расстояние между точками спроса и сервисом[^1]. Параметры решения будут зависеть от трех показателей:\n\n[^1]: Один из классических методов решения медианной задачи описан по [ссылке](https://transportgeography.org/contents/chapter2/transport-and-location/weber-location-triangle/)\n\n-   количество точек сервиса, которые необходимо разместить;\n\n-   количество, тип и размещение точек спроса - точки спроса могут представлять собой как индивидуальные локации, так и центры полигонов (например, административно-территориальных единиц), наиболее простым случаем здесь будет являться небольшое число равномерно распределенных по территории точек спроса;\n\n-   тип рассчитываемого расстояния.\n\nФактически решение этой задачи сводится к линейной оптимизации.\n\n$$ Min: \\sum_{a} \\sum_{b}g(Q(a,b)),\\ Q(a,b)\\geq0\n$$\n\nгде $Q(a,b)$ - трафик между источником $a$ и пунктом назначения $b$ , $g$ - функция стоимости.\n\nТо есть $g(Q(a,b))$ - транспортные расходы, связанные с перевозками из точки $a$ в пункт назначения $b$.\n\nДля анализа городской среды наиболее простым примером является поиск оптимального расположения объектов сервиса так, чтобы их зона обслуживания охватывала как можно больше горожан (потребителей этих сервисов) при минимальном до них расстоянии.\n\n![Размещение и площадь распределительных складов Amazon с учетом расселения[^2]](images/Map-Amazon-Density-and-Median-1.webp){fig-align=\"center\"}\n\n[^2]: Источник: <https://transportgeography.org/contents/methods/location-allocation-models/weighted-median-location-amazon-distribution-facilities/>\n\n[^3]: Источник: <https://transportgeography.org/contents/methods/location-allocation-models/weighted-median-location-amazon-distribution-facilities/>\n\n![Поиск наиболее оптимального расположения больниц[^4]](images/Без%20заголовка.png){fig-align=\"center\"}\n\n[^4]: Источник: <https://www.esri.com/about/newsroom/wp-content/uploads/2018/10/solving-a-public-health-problem.pdf>\n\n[^5]: Источник: <https://www.esri.com/about/newsroom/wp-content/uploads/2018/10/solving-a-public-health-problem.pdf>\n\n# Определение ближайшего сервиса на основе матрицы старт-назначение\n\nВ этой работе мы определим ближайшую локацию сервиса относительно жилых домов с использованием матрицы старт-назначение.\n\n::: callout-note\nМатрица старт-назначение - таблица, содержащая в себе значения времени или расстояния перевозки между всеми возможными парами стартовых точек и точек назначения.\n:::\n\n![Пример матрицы старт-назначение[^6]](images/generated_webp_full_reading-matrix.webp){fig-align=\"center\"}\n\n[^6]: Источник: <https://docs.platform-xyzt.ai/articles/origin-destination/introduction.html>\n\n[^7]: Источник: <https://docs.platform-xyzt.ai/articles/origin-destination/introduction.html>\n\nПрактическое занятие основано на [туториале](https://www.qgistutorials.com/en/docs/3/origin_destination_matrix.html).\n\n## Исходные данные {#location-allocation-data}\n\nДля расчетов нам необходимо три набора данных:\n\n-   жилые дома (полигоны) - точки спроса, которые будут служит стартовыми точками для расчета матрицы старт-назначение;\n\n-   точки сервиса (точки), которые будут служить конечными точками при расчете матрицы старт-назначение (вы можете выбрать точки сервиса, которые посчитаете нужным);\n\n-   улично-дорожная сеть (линейные объекты) для расчета расстояния или времени в пути.\n\nВсе данные следует загрузить из OSM с использованием плагина QuickOSM.\n\n::: callout-tip\nКак пользоваться плагином описано по [ссылке](https://baltti.github.io/geoinformatics-2.0/osm.html#quickosm)\n:::\n\nДля загрузки жилых домов будет использован запрос `building=apartments`.\n\nДля точек сервиса можно использовать одно из значений ключа `amenity` (подробнее [здесь](https://wiki.openstreetmap.org/wiki/RU:Key:amenity)) или `shop` (подробнее про него [здесь](https://wiki.openstreetmap.org/wiki/RU:Key:shop)). Здесь будут использованы супермаркеты, поэтому был использован запрос `shop=supermarket` .\n\nОбъекты улично-дорожной сети определялись по запросу `highway=primary or highway=secondary or highway=tertiary`.\n\n::: callout-warning\nВ нашем пример для построения маршрутов будут учитываться только наиболее крупные городские магистрали для ускорения и упрощения расчетов, что может привести к не очень реалистичной картине доступности сервисов. Если вы хотите выполнить расчет более корректно, лучше будет включить в него и более мелкие улицы. Полный перечень типов дорог и значений ключей для них приведен по [ссылке](https://wiki.openstreetmap.org/wiki/RU:Key:highway).\n:::\n\n![Подготовленный для анализа проект с загруженными слоями](images/Снимок%20экрана%202025-02-21%20в%2012.52.58.png){fig-align=\"center\"}\n\n::: callout-warning\nЧем больше будет ваша территория для анализа, тем дольше будет осуществляться расчет. То же самое касается и количества объектов: чем больше у вас домов или точек сервиса, тем дольше будут идти расчеты.\n:::\n\n## Расчет матрицы старт-назначение\n\nДля расчета матрицы воспользуемся уже знакомым нам по прошлому семестру плагином QNEAT3.\n\nНо предварительно нужно подготовить наши данные о жилых домах: пока они у нас представлены в виде полигонов, но плагин может осуществлять расчеты только между двумя слоями точечных объектов, поэтому необходимо из полигонов получить точки.\n\nПерейти от точек к полигонам мы можем либо построив центроиды, либо воспользовавшись инструментом *Точка на поверхности*.\n\nВ первом варианте мы получим геометрические центры полигонов, но в случае сложной формы зданий, они могу лежать за его пределами, тогда как при использовании инструмента *Точка на поверхность* полученные точечные объекты будут гарантированно размещены внутри полигонов.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.06.51.png){fig-align=\"center\"}\n\nВ данном случае было выбрано создавать точки для каждой части мультиполигонов, чтобы не были потеряны отдельные части зданий.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.09.45.png){fig-align=\"center\"}\n\n::: callout-tip\nДля улучшения качества расчетов можно воспользоваться не просто центром здания, а точками подъездов.\n:::\n\nДалее построим матрицу старт-назначение. Для этого воспользуемся инструментом *OD Matrix from Layers as Lines (m:n)*. В данном случае мы построим не просто таблицу, а векторный линейный слой, в котором будут соединяться все возможные пары дом-супермаркет.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.11.57.png){fig-align=\"center\"}\n\nВ качестве необходимых параметров следует указать:\n\n-   *network layer* - слой, содержащий объекты улично-дорожной сети;\n\n-   *from-point layer* - слой стартовых точек;\n\n-   *unique point ID field* - **уникальный идентификатор** стартовых точек;\n\n-   *to-point layer* - слой конечных точек;\n\n-   *unique point ID field* - **уникальный идентификатор** конечных точек;\n\n-   *optimization criterion* - показатель, минимизируемый при расчете маршрута: кратчайший или быстрейший).\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.12.24.png){fig-align=\"center\"}\n\nВ дополнительных параметрах укажем среднюю скорость пешехода - 5 км/ч (*default speed*) и стиль генерации линий - по прямой (*generated matrix geometry style*). Второй вариант генерации линий будет повторять сегменты улично-дорожной сети, но такое построение требует большего времени и ресурса компьютера, поэтому остановимся на более простом варианте.\n\nПо результатам расчета вы получите довольно неясную картинку, в которой будет много пересекающихся между собой линий - это графическая интерпретация матрицы старт-назначение.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.22.40.png){fig-align=\"center\"}\n\nЕсли вы откроете таблицу атрибутов полученного слоя, вы увидите собственно матрицу старт-назначение.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.24.25.png){fig-align=\"center\"}\n\nОбратите внимание, что расстояние в пути (cost) представлено сразу четырьмя атрибутами:\n\n-   *entry_cost* - расстояние, которое нужно пройти, чтобы от стартовой точки попасть на ближайший сегмент улично-дорожной сети;\n\n-   *network_cost* - расстояние, которое будет пройдено только по сегментам улично-дорожной сети;\n\n-   *exit_cost -* расстояние, которое нужно пройти от ближайшего к конечной точке сегмента улично-дорожной сети до конечной точки;\n\n-   *total_cost* - сумма перечисленных выше расстояний.\n\n## Определение ближайшего объекта сервиса\n\nПоследний шаг нашего расчета - это из всех возможных пар жилой дом-супермаркет найти те, которые расположены ближе всего друг к другу. Для этого мы выполним SQL-запрос.\n\nВ качестве источника данных следует выбрать вычисленную матрицу старт-назначение (в моем случае это слой *Output OD matrix*), а сам запрос будет выглядеть следующим образом:\n\n```         \nselect origin_id, destination_id, min(total_cost) as shortest_distance, geometry\nfrom input1 group by origin_id\n```\n\nТак как структура матрицы стандартна, то и запрос будет выглядеть у всех одинаково.\n\n::: callout-tip\nОбратите внимание на то, что в запросе использован поиск минимального значения для поля *total_cost*, так как нам необходимо найти ближайшие к жилым домам супермаркеты, кроме того здесь использован псевдоним этого поля (задается с помощью *as*).\n\nТакже следует отметить, что необходимо включать в запрос поле *geometry*, так как без него будет осуществлен только поиск прочих атрибутов и геометрия будет исключена.\n:::\n\nВ результате выполнения запроса будет получен новый слой, показывающий жители каких домов наиболее вероятно будут ходить в какие магазины, так как эти магазины являются к ним ближайшими. Также этот результат можно рассматривать как зоны обслуживания магазинов.\n\n![](images/Снимок%20экрана%202025-02-21%20в%2013.40.26.png){fig-align=\"center\"}\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":true,"shift-heading-level-by":1,"output-file":"02-location-allocation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":"cosmo","number-depth":3,"anchor-sections":true,"title":"Анализ размещения-распределения"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
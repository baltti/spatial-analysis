{"title":"Гравитационная модель Хаффа","markdown":{"yaml":{"title":"Гравитационная модель Хаффа","format":"html"},"headingText":"Теория","containsRefs":false,"markdown":"\n\n\nМатериалы лекции\n\n```{=html}\n<iframe src=\"https://baltti.github.io/gravity-model/\" width=\"1000\" height=\"500\"></iframe>\n```\n\n[Открыть лекцию в новой вкладке](https://baltti.github.io/gravity-model/){target=\"_blank\"}\n\n# Исходные данные\n\nВ качестве исходных данных нам необходимы:\n\n-   жилые дома - место жизни наших потенциальных покупателей;\n\n-   улично-дорожная сеть, которая будет использоваться для расчета времени в пути от жилого дома до магазина;\n\n-   слой с локациями торговых точек.\n\nПервые два слоя необходимо скачать из OSM аналогично [исходным данным в предыдущей работе](https://baltti.github.io/spatial-analysis/02-location-allocation.html#%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5) или же можно взять из предыдущей работы готовые данные.\n\nСлой с локациями торговых точек мы создадим самостоятельно. Для этого в строке меню необходимо выбрать *Слой* $\\longrightarrow$ *Создать слой* $\\longrightarrow$ *Создать слой GeoPackage*.\n\nДалее в открывшемся окне следует указать характеристики слоя:\n\n-   база данных - это путь к файлу, в котором будет храниться слой;\n\n-   имя таблицы - название слоя, которое будет отображаться в панели слоев;\n\n-   тип геометрии - нам нужны точечные объекты;\n\n-   система координат - можно оставить географическую систему координат по умолчанию, она будет совпадать с системой координат данных, скачанных из OSM;\n\n-   список полей, который будет включать два обязательных для нас поля - **name** (название магазина, текстовый формат данных) и **area** (площадь магазина в метрах квадратных, целое число).\n\n![](images/Снимок%20экрана%202025-02-21%20в%2017.15.27.png){fig-align=\"center\"}\n\nПосле создания слоя, его необходимо будет сделать редактируемым и нарисовать на карте несколько точек в разных частях исследуемой территории и заполнить для них атрибутивные данные - название магазина и площадь.\n\n::: callout-warning\nНазвания точек должны быть уникальными, в противном случае модель не будет работать.\n:::\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.04.14.png){fig-align=\"center\"}\n\n# Построение геомодели {#geomodel .section}\n\nВ этой работе мы будем оценивать вероятность посещения того или иного магазина, исходя из их доступности и площади (как прокси-метрики разнообразия ассортимента), с использованием гравитационной модели Хаффа.\n\n$$P_{ij} = \\frac{\\frac{S_{j}}{T^\\lambda_{ij}}}{\\sum_{j}^{n}\\frac{S_{j}}{T^\\lambda_{ij}}}$$\n\n-   $P_{ij}$ - вероятность того, что покупатель из локации $i$ пойдет в магазин $j$;\n-   $S_{j}$ - площадь магазина $j$;\n-   $T_{ij}$ - время/расстояние, которое нужно преодолеть, чтобы попасть в магазин;\n-   $\\lambda$ - параметр, отражающий влияние времени в пути на покупателя.\n\n::: callout-warning\nМы воспользуемся упрощенной моделью, приняв параметр $\\lambda$ равным единице, так как у нас нет подробных данных о предпочтениях покупателей.\n:::\n\nДля построения моделей будем использовать редактор моделей.\n\n::: callout-tip\nРедактор моделей позволяет выстроить последовательный процесс вычислений из цепочки операций с помощью простого графического интерфейса.\n\nПолученная геомодель позволяет автоматизировать вычисления и избежать вывода промежуточных результатов.\n\nПодробнее про построение геомоделей можно в [документации](https://docs.qgis.org/3.34/en/docs/user_manual/processing/modeler.html)\n:::\n\nОткрыть редактор моделей можно из строки меню *Анализ данных* $\\longrightarrow$ *Конструктор моделей* или по клику на кнопку *Модели* в Панели инструментов анализа.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.07.26.png){fig-align=\"center\"}\n\nВ открывшемся новом окне основная часть предназначена для отображения модели в графическом виде, слева панель данных и алгоритмов (переключаются по вкладкам внизу панели), свойства и переменные модели, а также история команд.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.08.29.png){fig-align=\"center\"}\n\n## Входные данные\n\nВ первую очередь зададим для нашей модели входные данные. В нашем случае все входные данные будут представлены в виде векторных слоев:\n\n-   здания - обязательный параметр, полигоны;\n\n-   магазины - обазятельный параметр, точки;\n\n-   улично-дорожная сеть - обязательный параметр, линии.\n\n::: callout-note\nОбязательный параметр - это тот, без включения которого в исходные данные запуск модели осуществляться не будет.\n:::\n\n::: callout-warning\nЖелательно называть входные данные буквами английского алфавита, так как иногда они могут не добавляться в модель или работать некорректно при использовании кириллицы.\n:::\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.15.30.png){fig-align=\"center\"}\n\nВходные данные в модели обозначаются зеленым плюсом перед названием.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.16.30.png){fig-align=\"center\"}\n\n## Расчет матрицы старт-назначение между потребителями и сервисами\n\nТакже как и для анализа размещения-распределения нам необходимо преобразовать полигональные здания в точечные объекты с помощью инструмента *Точка на поверхности*.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.20.56.png){fig-align=\"center\"}\n\nВ модели появится первый шаг, соединенный с одним из исходных параметров.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.21.30.png){fig-align=\"center\"}\n\nДалее мы можем непосредственно рассчитать матрицу старт-назначение с использованием плагина QNEAT3.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.23.16.png){fig-align=\"center\"}\n\nПараметры здесь указываются аналогично тому, как указывались просто в инструменте для построения матрицы.\n\nТак как нам здесь нет необходимости впоследствии визуально отображать пути покупателей от жилых домов до магазинов, то строить матрицу будем просто в виде таблицы на основе двух слоев.\n\n::: callout-warning\nИдентификаторы объектов стартовых и конечных точек должны быть уникальными (внутри слоя естественно).\n\nВ нашем случае для стартовых точек (домов) будет использовать *osm_id*, который всегда будет уникальным и есть в этом слое, так как данные брались из OSM, а для магазинов будет использоваться поле имени *name* (поэтому нам очень важно, чтобы в этом слое названия магазинов были уникальными).\n:::\n\nТак как в качестве стартовых точек мы используем не непостредственно здания, а результат применения инструмента *Точки на поверхности*, то необходимо выбрать, что здесь мы хотим использовать результаты выхода этого алгоритма.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.28.29.png){fig-align=\"center\"}\n\nПолученный результат будет представлен только в виде **таблицы без атрибутов**, которую можно присоединить к одному из векторных слоев.\n\nТак как мы будет рассчитывать вероятность посещения того или иного магазина для каждого из жилых домов, то основной расчет вероятности будет осуществляться внутри атрибутов жилых домов. Поэтому значения времени или расстояния из матрицы старт-назначение присоединим к слою жилых домов.\n\nПрисоединение будет осуществляться по совпадающим значениям полей: у исходного слоя есть *osm_id*, а в матрице есть *origin_id* - идентификатор стартовой точки, который был взят из *osm_id* исходного слоя.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.36.08.png){fig-align=\"center\"}\n\n## Расчет вероятности посещения конкретного сервиса\n\nЕсли мы обратимся к формуле в начале раздела, то увидим, что в формуле используется не только расстояние между потребителями и сервисом, но и площадь сервиса.\n\nПоэтому атрибуты магазинов тоже следует присоединить к слою жилых домов.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.50.17.png){fig-align=\"center\"}\n\nПрисоединение здесь будет осуществляться по названию магазина к результатам предыдущего шага, поэтому в качестве связыющих полей будет использовано *destination_id* и поле *name* слоя с магазинами.\n\n::: callout-note\nОбратите внимание, что тип объединения здесь один-ко-многим, то есть если с объектом исходного слоя совпадет более одного объекта присоединяемого слоя, то исходный объект будет продублирован и к нему присоединен атрибут второго совпавшего объекта.\n\nВ нашем случае это необходимо так как нужно рассчитать вероятность для всех магазинов и, если мы присоединим только первый совпавший по атрибуту, то в расчет мы сможем включить только его и таким образом получим безальтернативную вероятность посещения только одного магазина.\n:::\n\n::: callout-tip\nДля того, чтобы не запутаться в однотипных операциях в одинаковыми названиями, вы можете менять его в графе *Описание* (*Description*).\n:::\n\nСледующим шагом рассчитаем числитель в формуле: $\\frac{S_{j}}{T^\\lambda_{ij}}$, разделив площадь каждого магазина на время в пути до него с помощью калькулятора полей.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.08.55.png){fig-align=\"center\"}\n\n::: callout-note\nКалькулятор полей здесь устроен почти также как и стандартный калькулятор в таблице атрибутов. Все функции и формулы стандратны.\n\n*Обязательно здесь необходимо указать название нового поля и тип данных*.\n:::\n\nСледующим шагом нужно рассчитать знаменатель модели: $\\sum_{j}^{n}\\frac{S_{j}}{T^\\lambda_{ij}}$.\n\nДля этого необходимо фактически просуммировать все полученные нами на предыдущем шаге значения, но только для каждого жилого дома и соответствующих магазинов. То есть нам нужно просуммировать не все значения по столбцу, а только значения соответствующие одному жилому дому.\n\nРасчет осуществим с использованием SQL-запроса и оконной функции внутри него.\n\n::: callout-tip\n**Оконная функция в SQL** - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.\n\nОсновное отличие оконной функции от группировки по параметру состоит в том, что количество строк в запросе не уменьшается по сравнении с исходной таблицей.\n\nПодробнее можно почитать по [ссылке](https://habr.com/ru/articles/664000/).\n:::\n\nПолучается, что в нашем запросе сначала таблица будет поделена на группы строк, соответствующие одному и тому же жилому дому (имеющие один и тот же индентификатор дома), а потом суммирование значений будет производиться только в пределах этих групп строк.\n\nСтруктура запроса:\n\n```         \nselect origin_id, destination_id, total_cost, area, area_time, geometry,  sum(area_time) over (partition by origin_id) as summa from input1\n```\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.18.07.png){fig-align=\"center\"}\n\nИ последним шагом рассчитаем вероятность посещения того или иного магазина, еще раз использовав калькулятор полей и поделив друг на друга два полученных нами на последних шагах значения.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.21.46.png){fig-align=\"center\"}\n\nЭтот результат уже можно рассматривать как итоговый и ввести его название, чтобы это считалось выводом всей модели.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.22.19.png){fig-align=\"center\"}\n\nПолученная схема модели показана на рисунке ниже.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.23.30.png){fig-align=\"center\"}\n\nПеред запуском модель можно проверить командой из строки меню *Модель* $\\longrightarrow$ *Проверить модель*.\n\nЗапуск модели осуществляется либо по кнопке ![](images/Снимок%20экрана%202025-02-24%20в%2015.25.27.png){width=\"21\"}, либо из строки меню *Модель* $\\longrightarrow$ *Запустить модель.*\n\nПосле запуска модель выглядит практически как стандартный инструмент из Панели инструментов анализа.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.26.48.png){fig-align=\"center\"}\n\nПолученный результат на карте будет выглядеть идентично исходному слою жилых зданий, так как использовалась их неизмененная геометрия.\n\nСамая интересная часть результатов - это атрибутивная таблица со всеми значениями.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.32.37.png){fig-align=\"center\"}\n\nВ этой таблице как раз можно увидеть повторяемость каждого из зданий (обратите внимание, что в колонке *origin_id* значения повторяются столько раз, сколько у вас было магазинов в примере):\n\n-   *origin_id* - идентификатор дома из исходных данных;\n\n-   *destination_id* - идентификатор (название) магазина из исходных данных;\n\n-   *total_cost* - расстояние от конкретного дома до магазина из матрицы старт-назначение;\n\n-   *area* - площадь магазина из исходных данных;\n\n-   *area_time -* отношение площади магазина к расстоянию, рассчитанное на промежуточном этапе;\n\n-   *summa -* сумма всех предыдущих значение для каждого дома;\n\n-   *probability* - вероятность посещения конкретного магазина жителями этого дома.\n\n::: callout-tip\nПроверить корректность своих расчетов можно проверив два условия:\n\n-   вероятность (последняя колонка может находиться только в пределах от нуля до единицы);\n\n-   сумма вероятностей для каждого дома должна равняться единице.\n:::\n\nВ качестве финального этапа можем разделить полученный в итоге слой так, чтобы для каждого из магазинов был свой отдельный слой.\n\nДля этого воспользуемся инструментом *Разбить векторный слой* и разобьем его на отдельные слои по идентификаторам магазинов.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.40.16.png){fig-align=\"center\"}\n\nЗдесь результат тоже будет выводиться как конечный.\n\nТаким образом, по результату запуска модели будет выводиться слой, содержащий вероятности по всем домам и магазинам, и слои, содержащие вероятности по отдельным магазинам (этих слоев будет столько, сколько было магазинов в исходном слое).\n\n::: callout-tip\nПри необходимости вы можете сделать столько выводов из модели, сколько посчитаете нужным.\n:::\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.44.05.png){fig-align=\"center\"}\n\nОкно запуска модели немного изменится: в нем появится возможность выбора папки для сохранения наших результатов разделения слоя.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.44.38.png){fig-align=\"center\"}\n\nВ выбранной папке по результатам работы модели появятся файлы с префиксом *destination_id\\_* и названием магазина: ![](images/Снимок%20экрана%202025-02-24%20в%2015.46.44.png).\n\nАтрибутивная таблица сохранит свою структуру, но, естественно будет содержать только данные по одному из магазинов.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.48.24.png){fig-align=\"center\"}\n\nПолученная модель может быть сохранена как отдельный файл в формате *.model3* (*Модель* $\\longrightarrow$ *Сохранить модель как*) или как часть проекта (*Модель* $\\longrightarrow$ *Сохранить модель в проекте).*\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.49.45.png){fig-align=\"center\"}\n\n::: callout-tip\nЕсли бы было известно количество жителей в каждом доме, то можно было бы рассчитать потенциальное число покупателей для каждого из магазинов по формуле:\n\n$$\nE_{ij} = P_{ij}C_{i}\n$$\n\nгде $E_{ij}$ - предполагаемое количество покупателей из локации $i$, которые пойдут в магазин $j$;\n\n$P_{ij}$ - вероятность того, что покупатель из локации $i$ пойдет в магазин $j$;\n\n$C_{i}$ - количество покупателей в локации $i$.\n:::\n","srcMarkdownNoYaml":"\n\n# Теория\n\nМатериалы лекции\n\n```{=html}\n<iframe src=\"https://baltti.github.io/gravity-model/\" width=\"1000\" height=\"500\"></iframe>\n```\n\n[Открыть лекцию в новой вкладке](https://baltti.github.io/gravity-model/){target=\"_blank\"}\n\n# Исходные данные\n\nВ качестве исходных данных нам необходимы:\n\n-   жилые дома - место жизни наших потенциальных покупателей;\n\n-   улично-дорожная сеть, которая будет использоваться для расчета времени в пути от жилого дома до магазина;\n\n-   слой с локациями торговых точек.\n\nПервые два слоя необходимо скачать из OSM аналогично [исходным данным в предыдущей работе](https://baltti.github.io/spatial-analysis/02-location-allocation.html#%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5) или же можно взять из предыдущей работы готовые данные.\n\nСлой с локациями торговых точек мы создадим самостоятельно. Для этого в строке меню необходимо выбрать *Слой* $\\longrightarrow$ *Создать слой* $\\longrightarrow$ *Создать слой GeoPackage*.\n\nДалее в открывшемся окне следует указать характеристики слоя:\n\n-   база данных - это путь к файлу, в котором будет храниться слой;\n\n-   имя таблицы - название слоя, которое будет отображаться в панели слоев;\n\n-   тип геометрии - нам нужны точечные объекты;\n\n-   система координат - можно оставить географическую систему координат по умолчанию, она будет совпадать с системой координат данных, скачанных из OSM;\n\n-   список полей, который будет включать два обязательных для нас поля - **name** (название магазина, текстовый формат данных) и **area** (площадь магазина в метрах квадратных, целое число).\n\n![](images/Снимок%20экрана%202025-02-21%20в%2017.15.27.png){fig-align=\"center\"}\n\nПосле создания слоя, его необходимо будет сделать редактируемым и нарисовать на карте несколько точек в разных частях исследуемой территории и заполнить для них атрибутивные данные - название магазина и площадь.\n\n::: callout-warning\nНазвания точек должны быть уникальными, в противном случае модель не будет работать.\n:::\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.04.14.png){fig-align=\"center\"}\n\n# Построение геомодели {#geomodel .section}\n\nВ этой работе мы будем оценивать вероятность посещения того или иного магазина, исходя из их доступности и площади (как прокси-метрики разнообразия ассортимента), с использованием гравитационной модели Хаффа.\n\n$$P_{ij} = \\frac{\\frac{S_{j}}{T^\\lambda_{ij}}}{\\sum_{j}^{n}\\frac{S_{j}}{T^\\lambda_{ij}}}$$\n\n-   $P_{ij}$ - вероятность того, что покупатель из локации $i$ пойдет в магазин $j$;\n-   $S_{j}$ - площадь магазина $j$;\n-   $T_{ij}$ - время/расстояние, которое нужно преодолеть, чтобы попасть в магазин;\n-   $\\lambda$ - параметр, отражающий влияние времени в пути на покупателя.\n\n::: callout-warning\nМы воспользуемся упрощенной моделью, приняв параметр $\\lambda$ равным единице, так как у нас нет подробных данных о предпочтениях покупателей.\n:::\n\nДля построения моделей будем использовать редактор моделей.\n\n::: callout-tip\nРедактор моделей позволяет выстроить последовательный процесс вычислений из цепочки операций с помощью простого графического интерфейса.\n\nПолученная геомодель позволяет автоматизировать вычисления и избежать вывода промежуточных результатов.\n\nПодробнее про построение геомоделей можно в [документации](https://docs.qgis.org/3.34/en/docs/user_manual/processing/modeler.html)\n:::\n\nОткрыть редактор моделей можно из строки меню *Анализ данных* $\\longrightarrow$ *Конструктор моделей* или по клику на кнопку *Модели* в Панели инструментов анализа.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.07.26.png){fig-align=\"center\"}\n\nВ открывшемся новом окне основная часть предназначена для отображения модели в графическом виде, слева панель данных и алгоритмов (переключаются по вкладкам внизу панели), свойства и переменные модели, а также история команд.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.08.29.png){fig-align=\"center\"}\n\n## Входные данные\n\nВ первую очередь зададим для нашей модели входные данные. В нашем случае все входные данные будут представлены в виде векторных слоев:\n\n-   здания - обязательный параметр, полигоны;\n\n-   магазины - обазятельный параметр, точки;\n\n-   улично-дорожная сеть - обязательный параметр, линии.\n\n::: callout-note\nОбязательный параметр - это тот, без включения которого в исходные данные запуск модели осуществляться не будет.\n:::\n\n::: callout-warning\nЖелательно называть входные данные буквами английского алфавита, так как иногда они могут не добавляться в модель или работать некорректно при использовании кириллицы.\n:::\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.15.30.png){fig-align=\"center\"}\n\nВходные данные в модели обозначаются зеленым плюсом перед названием.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.16.30.png){fig-align=\"center\"}\n\n## Расчет матрицы старт-назначение между потребителями и сервисами\n\nТакже как и для анализа размещения-распределения нам необходимо преобразовать полигональные здания в точечные объекты с помощью инструмента *Точка на поверхности*.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.20.56.png){fig-align=\"center\"}\n\nВ модели появится первый шаг, соединенный с одним из исходных параметров.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.21.30.png){fig-align=\"center\"}\n\nДалее мы можем непосредственно рассчитать матрицу старт-назначение с использованием плагина QNEAT3.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.23.16.png){fig-align=\"center\"}\n\nПараметры здесь указываются аналогично тому, как указывались просто в инструменте для построения матрицы.\n\nТак как нам здесь нет необходимости впоследствии визуально отображать пути покупателей от жилых домов до магазинов, то строить матрицу будем просто в виде таблицы на основе двух слоев.\n\n::: callout-warning\nИдентификаторы объектов стартовых и конечных точек должны быть уникальными (внутри слоя естественно).\n\nВ нашем случае для стартовых точек (домов) будет использовать *osm_id*, который всегда будет уникальным и есть в этом слое, так как данные брались из OSM, а для магазинов будет использоваться поле имени *name* (поэтому нам очень важно, чтобы в этом слое названия магазинов были уникальными).\n:::\n\nТак как в качестве стартовых точек мы используем не непостредственно здания, а результат применения инструмента *Точки на поверхности*, то необходимо выбрать, что здесь мы хотим использовать результаты выхода этого алгоритма.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.28.29.png){fig-align=\"center\"}\n\nПолученный результат будет представлен только в виде **таблицы без атрибутов**, которую можно присоединить к одному из векторных слоев.\n\nТак как мы будет рассчитывать вероятность посещения того или иного магазина для каждого из жилых домов, то основной расчет вероятности будет осуществляться внутри атрибутов жилых домов. Поэтому значения времени или расстояния из матрицы старт-назначение присоединим к слою жилых домов.\n\nПрисоединение будет осуществляться по совпадающим значениям полей: у исходного слоя есть *osm_id*, а в матрице есть *origin_id* - идентификатор стартовой точки, который был взят из *osm_id* исходного слоя.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.36.08.png){fig-align=\"center\"}\n\n## Расчет вероятности посещения конкретного сервиса\n\nЕсли мы обратимся к формуле в начале раздела, то увидим, что в формуле используется не только расстояние между потребителями и сервисом, но и площадь сервиса.\n\nПоэтому атрибуты магазинов тоже следует присоединить к слою жилых домов.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2013.50.17.png){fig-align=\"center\"}\n\nПрисоединение здесь будет осуществляться по названию магазина к результатам предыдущего шага, поэтому в качестве связыющих полей будет использовано *destination_id* и поле *name* слоя с магазинами.\n\n::: callout-note\nОбратите внимание, что тип объединения здесь один-ко-многим, то есть если с объектом исходного слоя совпадет более одного объекта присоединяемого слоя, то исходный объект будет продублирован и к нему присоединен атрибут второго совпавшего объекта.\n\nВ нашем случае это необходимо так как нужно рассчитать вероятность для всех магазинов и, если мы присоединим только первый совпавший по атрибуту, то в расчет мы сможем включить только его и таким образом получим безальтернативную вероятность посещения только одного магазина.\n:::\n\n::: callout-tip\nДля того, чтобы не запутаться в однотипных операциях в одинаковыми названиями, вы можете менять его в графе *Описание* (*Description*).\n:::\n\nСледующим шагом рассчитаем числитель в формуле: $\\frac{S_{j}}{T^\\lambda_{ij}}$, разделив площадь каждого магазина на время в пути до него с помощью калькулятора полей.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.08.55.png){fig-align=\"center\"}\n\n::: callout-note\nКалькулятор полей здесь устроен почти также как и стандартный калькулятор в таблице атрибутов. Все функции и формулы стандратны.\n\n*Обязательно здесь необходимо указать название нового поля и тип данных*.\n:::\n\nСледующим шагом нужно рассчитать знаменатель модели: $\\sum_{j}^{n}\\frac{S_{j}}{T^\\lambda_{ij}}$.\n\nДля этого необходимо фактически просуммировать все полученные нами на предыдущем шаге значения, но только для каждого жилого дома и соответствующих магазинов. То есть нам нужно просуммировать не все значения по столбцу, а только значения соответствующие одному жилому дому.\n\nРасчет осуществим с использованием SQL-запроса и оконной функции внутри него.\n\n::: callout-tip\n**Оконная функция в SQL** - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.\n\nОсновное отличие оконной функции от группировки по параметру состоит в том, что количество строк в запросе не уменьшается по сравнении с исходной таблицей.\n\nПодробнее можно почитать по [ссылке](https://habr.com/ru/articles/664000/).\n:::\n\nПолучается, что в нашем запросе сначала таблица будет поделена на группы строк, соответствующие одному и тому же жилому дому (имеющие один и тот же индентификатор дома), а потом суммирование значений будет производиться только в пределах этих групп строк.\n\nСтруктура запроса:\n\n```         \nselect origin_id, destination_id, total_cost, area, area_time, geometry,  sum(area_time) over (partition by origin_id) as summa from input1\n```\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.18.07.png){fig-align=\"center\"}\n\nИ последним шагом рассчитаем вероятность посещения того или иного магазина, еще раз использовав калькулятор полей и поделив друг на друга два полученных нами на последних шагах значения.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.21.46.png){fig-align=\"center\"}\n\nЭтот результат уже можно рассматривать как итоговый и ввести его название, чтобы это считалось выводом всей модели.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.22.19.png){fig-align=\"center\"}\n\nПолученная схема модели показана на рисунке ниже.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.23.30.png){fig-align=\"center\"}\n\nПеред запуском модель можно проверить командой из строки меню *Модель* $\\longrightarrow$ *Проверить модель*.\n\nЗапуск модели осуществляется либо по кнопке ![](images/Снимок%20экрана%202025-02-24%20в%2015.25.27.png){width=\"21\"}, либо из строки меню *Модель* $\\longrightarrow$ *Запустить модель.*\n\nПосле запуска модель выглядит практически как стандартный инструмент из Панели инструментов анализа.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.26.48.png){fig-align=\"center\"}\n\nПолученный результат на карте будет выглядеть идентично исходному слою жилых зданий, так как использовалась их неизмененная геометрия.\n\nСамая интересная часть результатов - это атрибутивная таблица со всеми значениями.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.32.37.png){fig-align=\"center\"}\n\nВ этой таблице как раз можно увидеть повторяемость каждого из зданий (обратите внимание, что в колонке *origin_id* значения повторяются столько раз, сколько у вас было магазинов в примере):\n\n-   *origin_id* - идентификатор дома из исходных данных;\n\n-   *destination_id* - идентификатор (название) магазина из исходных данных;\n\n-   *total_cost* - расстояние от конкретного дома до магазина из матрицы старт-назначение;\n\n-   *area* - площадь магазина из исходных данных;\n\n-   *area_time -* отношение площади магазина к расстоянию, рассчитанное на промежуточном этапе;\n\n-   *summa -* сумма всех предыдущих значение для каждого дома;\n\n-   *probability* - вероятность посещения конкретного магазина жителями этого дома.\n\n::: callout-tip\nПроверить корректность своих расчетов можно проверив два условия:\n\n-   вероятность (последняя колонка может находиться только в пределах от нуля до единицы);\n\n-   сумма вероятностей для каждого дома должна равняться единице.\n:::\n\nВ качестве финального этапа можем разделить полученный в итоге слой так, чтобы для каждого из магазинов был свой отдельный слой.\n\nДля этого воспользуемся инструментом *Разбить векторный слой* и разобьем его на отдельные слои по идентификаторам магазинов.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.40.16.png){fig-align=\"center\"}\n\nЗдесь результат тоже будет выводиться как конечный.\n\nТаким образом, по результату запуска модели будет выводиться слой, содержащий вероятности по всем домам и магазинам, и слои, содержащие вероятности по отдельным магазинам (этих слоев будет столько, сколько было магазинов в исходном слое).\n\n::: callout-tip\nПри необходимости вы можете сделать столько выводов из модели, сколько посчитаете нужным.\n:::\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.44.05.png){fig-align=\"center\"}\n\nОкно запуска модели немного изменится: в нем появится возможность выбора папки для сохранения наших результатов разделения слоя.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.44.38.png){fig-align=\"center\"}\n\nВ выбранной папке по результатам работы модели появятся файлы с префиксом *destination_id\\_* и названием магазина: ![](images/Снимок%20экрана%202025-02-24%20в%2015.46.44.png).\n\nАтрибутивная таблица сохранит свою структуру, но, естественно будет содержать только данные по одному из магазинов.\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.48.24.png){fig-align=\"center\"}\n\nПолученная модель может быть сохранена как отдельный файл в формате *.model3* (*Модель* $\\longrightarrow$ *Сохранить модель как*) или как часть проекта (*Модель* $\\longrightarrow$ *Сохранить модель в проекте).*\n\n![](images/Снимок%20экрана%202025-02-24%20в%2015.49.45.png){fig-align=\"center\"}\n\n::: callout-tip\nЕсли бы было известно количество жителей в каждом доме, то можно было бы рассчитать потенциальное число покупателей для каждого из магазинов по формуле:\n\n$$\nE_{ij} = P_{ij}C_{i}\n$$\n\nгде $E_{ij}$ - предполагаемое количество покупателей из локации $i$, которые пойдут в магазин $j$;\n\n$P_{ij}$ - вероятность того, что покупатель из локации $i$ пойдет в магазин $j$;\n\n$C_{i}$ - количество покупателей в локации $i$.\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":true,"shift-heading-level-by":1,"output-file":"03-gravity-model.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":"cosmo","number-depth":3,"anchor-sections":true,"title":"Гравитационная модель Хаффа"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}